<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Market Basket Analysis Platform | DataInsight Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        :root {
            --primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --bg-card: rgba(255, 255, 255, 0.95);
            --text-primary: #2d3748;
            --text-secondary: #718096;
            --border: #e2e8f0;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--primary);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
        
        .header {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .header h1 {
            font-size: 3rem;
            font-weight: 800;
            background: var(--primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
        }
        
        .subtitle {
            font-size: 1.3rem;
            color: var(--text-secondary);
            margin-bottom: 25px;
        }
        
        .features {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .feature-badge {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
            padding: 8px 20px;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 500;
            color: #667eea;
        }
        
        .upload-section {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
        }
        
        .file-upload {
            border: 3px dashed #667eea;
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s ease;
            background: linear-gradient(135deg, #f8f9ff 0%, #f0f2ff 100%);
        }
        
        .file-upload:hover {
            border-color: #764ba2;
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .upload-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            background: var(--primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 15px 35px;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .analysis-preview {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border-left: 5px solid #667eea;
        }
        
        .column-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .selector-group {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .selector-group h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        select, input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 60px;
            background: var(--bg-card);
            border-radius: 20px;
            margin-bottom: 30px;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .results-section {
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }
        
        .stat-card {
            background: var(--bg-card);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary);
        }
        
        .stat-value {
            font-size: 2.8rem;
            font-weight: 800;
            background: var(--primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .card {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
        }
        
        .card h3 {
            color: var(--text-primary);
            margin-bottom: 25px;
            font-size: 1.4rem;
            font-weight: 700;
        }
        
        .chart-container {
            height: 400px;
            margin: 25px 0;
        }
        
        .rules-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
        }
        
        .rules-table th,
        .rules-table td {
            padding: 15px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        .rules-table th {
            background: var(--primary);
            color: white;
            font-weight: 600;
        }
        
        .rules-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .confidence-bar {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .confidence-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.8s ease;
        }
        
        .insights {
            background: var(--secondary);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 25px 0;
        }
        
        .insights h4 {
            margin-bottom: 20px;
            font-size: 1.3rem;
        }
        
        .insights ul {
            list-style: none;
            padding: 0;
        }
        
        .insights li {
            padding: 12px 0 12px 20px;
            border-left: 3px solid rgba(255, 255, 255, 0.3);
            margin: 15px 0;
        }
        
        .export-section {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .full-width { grid-column: 1 / -1; }
        
        @media (max-width: 768px) {
            .container { padding: 15px; }
            .header h1 { font-size: 2.2rem; }
            .analysis-grid { grid-template-columns: 1fr; }
        }
        
        .file-input { display: none; }
        
        .dataset-info {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .dataset-info h4 {
            color: #4CAF50;
            margin-bottom: 15px;
        }
        
        .data-sample {
            background: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            overflow-x: auto;
            max-height: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🛒 Universal Market Basket Analyzer</h1>
            <p class="subtitle">AI-Powered Analysis for Any Dataset Format</p>
            <div class="features">
                <span class="feature-badge">🤖 Auto-Detection</span>
                <span class="feature-badge">📊 Universal Format Support</span>
                <span class="feature-badge">🎯 Smart Column Selection</span>
                <span class="feature-badge">📈 Advanced Analytics</span>
                <span class="feature-badge">📋 Professional Reports</span>
            </div>
        </div>
        
        <div class="upload-section">
            <div class="file-upload" id="fileUpload">
                <div class="upload-icon">📊</div>
                <h3>Upload Any CSV Dataset</h3>
                <p>The system will automatically analyze and adapt to your data structure</p>
                <p style="margin-top: 10px; color: var(--text-secondary); font-size: 0.9rem;">
                    Supports: Transaction logs, Purchase records, Order data, Product matrices, Item lists
                </p>
            </div>
            <div style="text-align: center;">
                <input type="file" id="csvFile" class="file-input" accept=".csv">
                <button class="btn" onclick="document.getElementById('csvFile').click()">
                    📁 Choose Dataset
                </button>
                <button class="btn" id="analyzeBtn" onclick="startAnalysis()" disabled>
                    🚀 Analyze Data
                </button>
            </div>
            
            <div id="datasetPreview" style="display: none;"></div>
        </div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <h3>AI Processing Dataset...</h3>
            <p>Analyzing structure, detecting patterns, and performing market basket analysis</p>
        </div>
        
        <div class="results-section" id="resultsSection">
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-value" id="totalTransactions">0</div>
                    <div class="stat-label">Transactions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="uniqueProducts">0</div>
                    <div class="stat-label">Unique Products</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgBasketSize">0</div>
                    <div class="stat-label">Avg Basket Size</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="strongRules">0</div>
                    <div class="stat-label">Association Rules</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="revenueImpact">0%</div>
                    <div class="stat-label">Revenue Impact</div>
                </div>
            </div>
            
            <div class="analysis-grid">
                <div class="card">
                    <h3>📊 Product Frequency Analysis</h3>
                    <div class="chart-container">
                        <canvas id="frequencyChart"></canvas>
                    </div>
                </div>
                
                <div class="card">
                    <h3>🎯 Association Rules Visualization</h3>
                    <div class="chart-container">
                        <canvas id="rulesChart"></canvas>
                    </div>
                </div>
                
                <div class="card full-width">
                    <h3>🔗 Top Association Rules</h3>
                    <div id="rulesTable"></div>
                    
                    <div class="insights">
                        <h4>💡 AI-Generated Business Insights</h4>
                        <div id="businessInsights"></div>
                    </div>
                </div>
                
                <div class="card full-width">
                    <h3>📈 Cross-Selling Opportunities</h3>
                    <div class="chart-container">
                        <canvas id="crossSellChart"></canvas>
                    </div>
                    
                    <div id="recommendations">
                        <h4>🎯 Strategic Recommendations</h4>
                        <div id="actionableInsights"></div>
                    </div>
                    
                    <div class="export-section">
                        <button class="btn" onclick="exportToPDF()">📄 Export Report</button>
                        <button class="btn" onclick="exportToCSV()">📊 Export Rules</button>
                        <button class="btn" onclick="exportToJSON()">💾 Export Analysis</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let rawDataset = [];
        let processedTransactions = [];
        let analysisResults = {};
        let datasetStructure = {};
        
        // File handling
        document.getElementById('csvFile').addEventListener('change', handleFileUpload);
        document.getElementById('fileUpload').addEventListener('click', () => {
            document.getElementById('csvFile').click();
        });
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.toLowerCase().endsWith('.csv')) {
                alert('Please upload a CSV file');
                return;
            }
            
            Papa.parse(file, {
                complete: function(results) {
                    if (results.data && results.data.length > 1) {
                        rawDataset = results.data;
                        analyzeDatasetStructure();
                        document.getElementById('analyzeBtn').disabled = false;
                    } else {
                        alert('No data found in the CSV file');
                    }
                },
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false
            });
        }
        
        function analyzeDatasetStructure() {
            const headers = Object.keys(rawDataset[0]);
            const sampleSize = Math.min(100, rawDataset.length);
            const samples = rawDataset.slice(0, sampleSize);
            
            console.log('Analyzing dataset with headers:', headers);
            
            datasetStructure = {
                totalRows: rawDataset.length,
                columns: headers,
                transactionColumn: null,
                customerColumn: null,
                timestampColumn: null,
                amountColumn: null,
                productColumns: [],
                detectedFormat: '',
                confidence: 0
            };
            
            // Detect transaction ID column
            datasetStructure.transactionColumn = findBestColumn(headers, [
                'transaction', 'trans', 'invoice', 'order', 'receipt', 'id', 'tid'
            ]);
            
            // Detect customer column
            datasetStructure.customerColumn = findBestColumn(headers, [
                'customer', 'client', 'user', 'member', 'cust'
            ]);
            
            // Detect timestamp column
            datasetStructure.timestampColumn = findBestColumn(headers, [
                'date', 'time', 'timestamp', 'created', 'purchased'
            ]);
            
            // Detect amount/price column
            datasetStructure.amountColumn = findBestColumn(headers, [
                'amount', 'total', 'price', 'cost', 'value', 'revenue', 'sum'
            ]);
            
            // Analyze data patterns to determine format
            const formatAnalysis = analyzeDataFormat(samples, headers);
            datasetStructure.detectedFormat = formatAnalysis.format;
            datasetStructure.productColumns = formatAnalysis.productColumns;
            datasetStructure.confidence = formatAnalysis.confidence;
            
            displayDatasetPreview();
        }
        
        function findBestColumn(headers, keywords) {
            for (const keyword of keywords) {
                const match = headers.find(h => 
                    h.toLowerCase().includes(keyword.toLowerCase())
                );
                if (match) return match;
            }
            return null;
        }
        
        function analyzeDataFormat(samples, headers) {
            const analyses = [
                analyzeItemListFormat(samples, headers),
                analyzeBinaryMatrixFormat(samples, headers),
                analyzeProductColumnsFormat(samples, headers),
                analyzeSingleItemFormat(samples, headers),
                analyzeQuantityBasedFormat(samples, headers)
            ];
            
            // Return the format with highest confidence
            const bestAnalysis = analyses.reduce((best, current) => 
                current.confidence > best.confidence ? current : best
            );
            
            return bestAnalysis;
        }
        
        function analyzeItemListFormat(samples, headers) {
            // Look for columns that might contain comma-separated items
            const itemColumns = headers.filter(h => 
                h.toLowerCase().includes('item') ||
                h.toLowerCase().includes('product') ||
                h.toLowerCase().includes('description') ||
                h.toLowerCase().includes('name')
            );
            
            let maxConfidence = 0;
            let bestColumn = null;
            
            for (const col of itemColumns) {
                const values = samples.map(row => row[col]).filter(v => v && v.trim());
                if (values.length === 0) continue;
                
                const commaSeparated = values.filter(v => v.includes(',')).length;
                const confidence = commaSeparated / values.length;
                
                if (confidence > maxConfidence && confidence > 0.3) {
                    maxConfidence = confidence;
                    bestColumn = col;
                }
            }
            
            return {
                format: 'Item List (Comma-separated)',
                productColumns: bestColumn ? [bestColumn] : [],
                confidence: maxConfidence
            };
        }
        
        function analyzeBinaryMatrixFormat(samples, headers) {
            // Exclude obvious non-product columns
            const excludePatterns = [
                'id', 'transaction', 'customer', 'date', 'time', 'amount', 
                'total', 'price', 'quantity', 'qty'
            ];
            
            const potentialProductCols = headers.filter(h => 
                !excludePatterns.some(pattern => h.toLowerCase().includes(pattern))
            );
            
            if (potentialProductCols.length < 3) {
                return { format: 'Binary Matrix', productColumns: [], confidence: 0 };
            }
            
            let binaryScore = 0;
            const validCols = [];
            
            for (const col of potentialProductCols) {
                const values = samples.map(row => row[col]).filter(v => v !== null && v !== undefined && v !== '');
                if (values.length === 0) continue;
                
                const uniqueValues = [...new Set(values)];
                const isBinary = uniqueValues.every(v => 
                    v === 0 || v === 1 || v === '0' || v === '1' ||
                    v === true || v === false ||
                    v === 'TRUE' || v === 'FALSE' ||
                    v === 'Yes' || v === 'No'
                ) && uniqueValues.length <= 3;
                
                if (isBinary) {
                    binaryScore++;
                    validCols.push(col);
                }
            }
            
            const confidence = potentialProductCols.length > 0 ? binaryScore / potentialProductCols.length : 0;
            
            return {
                format: 'Binary Matrix (0/1 indicators)',
                productColumns: validCols,
                confidence: confidence
            };
        }
        
        function analyzeProductColumnsFormat(samples, headers) {
            const excludePatterns = [
                'id', 'transaction', 'customer', 'date', 'time', 'amount', 'total', 'price'
            ];
            
            const potentialProductCols = headers.filter(h => 
                !excludePatterns.some(pattern => h.toLowerCase().includes(pattern))
            );
            
            let textDataScore = 0;
            const validCols = [];
            
            for (const col of potentialProductCols) {
                const values = samples.map(row => row[col]).filter(v => v && v.trim && v.trim() !== '');
                if (values.length === 0) continue;
                
                const hasTextData = values.some(v => typeof v === 'string' && v.length > 1);
                if (hasTextData) {
                    textDataScore++;
                    validCols.push(col);
                }
            }
            
            const confidence = potentialProductCols.length > 0 ? textDataScore / potentialProductCols.length : 0;
            
            return {
                format: 'Product Columns (Text data)',
                productColumns: validCols,
                confidence: Math.min(confidence, 0.8) // Cap at 0.8 to prefer more specific formats
            };
        }
        
        function analyzeSingleItemFormat(samples, headers) {
            // Check if there's a clear item/product column with one item per row
            const itemColumn = headers.find(h => 
                h.toLowerCase().includes('item') ||
                h.toLowerCase().includes('product') ||
                h.toLowerCase().includes('description')
            );
            
            if (!itemColumn) {
                return { format: 'Single Item per Row', productColumns: [], confidence: 0 };
            }
            
            const values = samples.map(row => row[itemColumn]).filter(v => v && v.trim);
            const nonCommaValues = values.filter(v => !v.includes(','));
            const confidence = values.length > 0 ? nonCommaValues.length / values.length : 0;
            
            return {
                format: 'Single Item per Row',
                productColumns: [itemColumn],
                confidence: confidence * 0.7 // Lower preference
            };
        }
        
        function analyzeQuantityBasedFormat(samples, headers) {
            const itemColumn = headers.find(h => 
                h.toLowerCase().includes('item') ||
                h.toLowerCase().includes('product')
            );
            
            const qtyColumns = headers.filter(h => 
                h.toLowerCase().includes('qty') ||
                h.toLowerCase().includes('quantity') ||
                h.toLowerCase().includes('count')
            );
            
            if (!itemColumn || qtyColumns.length === 0) {
                return { format: 'Quantity-based', productColumns: [], confidence: 0 };
            }
            
            return {
                format: 'Quantity-based (Items with quantities)',
                productColumns: [itemColumn, ...qtyColumns],
                confidence: 0.6
            };
        }
        
        function displayDatasetPreview() {
            const preview = document.getElementById('datasetPreview');
            const sampleData = rawDataset.slice(0, 3);
            
            const previewHTML = `
                <div class="dataset-info">
                    <h4>🔍 Dataset Analysis Complete</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                        <div><strong>📊 Total Records:</strong> ${datasetStructure.totalRows.toLocaleString()}</div>
                        <div><strong>📋 Columns:</strong> ${datasetStructure.columns.length}</div>
                        <div><strong>🎯 Detected Format:</strong> ${datasetStructure.detectedFormat}</div>
                        <div><strong>✅ Confidence:</strong> ${Math.round(datasetStructure.confidence * 100)}%</div>
                    </div>
                    
                    <div style="margin: 20px 0;">
                        <strong>🔧 Auto-detected Structure:</strong>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            ${datasetStructure.transactionColumn ? `<li><strong>Transaction ID:</strong> ${datasetStructure.transactionColumn}</li>` : ''}
                            ${datasetStructure.customerColumn ? `<li><strong>Customer:</strong> ${datasetStructure.customerColumn}</li>` : ''}
                            ${datasetStructure.timestampColumn ? `<li><strong>Timestamp:</strong> ${datasetStructure.timestampColumn}</li>` : ''}
                            ${datasetStructure.amountColumn ? `<li><strong>Amount:</strong> ${datasetStructure.amountColumn}</li>` : ''}
                            <li><strong>Product Data:</strong> ${datasetStructure.productColumns.length} columns (${datasetStructure.productColumns.slice(0, 3).join(', ')}${datasetStructure.productColumns.length > 3 ? '...' : ''})</li>
                        </ul>
                    </div>
                    
                    <div>
                        <strong>📝 Data Sample:</strong>
                        <div class="data-sample">
                            ${JSON.stringify(sampleData, null, 2)}
                        </div>
                    </div>
                </div>
            `;
            
            preview.innerHTML = previewHTML;
            preview.style.display = 'block';
        }
        
        function startAnalysis() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';
            
            setTimeout(() => {
                try {
                    // Process data based on detected format
                    processedTransactions = processDataset();
                    
                    // Perform market basket analysis
                    analysisResults = performMarketBasketAnalysis();
                    
                    // Update UI
                    updateStatistics();
                    createVisualizationCharts();
                    generateBusinessInsights();
                    
                    // Show results
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('resultsSection').style.display = 'block';
                    
                } catch (error) {
                    console.error('Analysis error:', error);
                    alert('Error during analysis: ' + error.message);
                    document.getElementById('loading').style.display = 'none';
                }
            }, 2000);
        }
        
        function processDataset() {
            const transactions = [];
            
            rawDataset.forEach((row, index) => {
                const items = extractItems(row, datasetStructure);
                
                if (items.length > 0) {
                    transactions.push({
                        id: row[datasetStructure.transactionColumn] || `txn_${index}`,
                        customerId: row[datasetStructure.customerColumn] || `customer_${index % 1000}`,
                        timestamp: parseTimestamp(row[datasetStructure.timestampColumn]) || generateRandomDate(),
                        amount: parseFloat(row[datasetStructure.amountColumn]) || (items.length * (Math.random() * 20 + 10)),
                        items: items
                    });
                }
            });
            
            console.log(`Processed ${transactions.length} transactions from ${rawDataset.length} rows`);
            
            if (transactions.length === 0) {
                throw new Error('No valid transactions found in the dataset');
            }
            
            return transactions;
        }
        
        function extractItems(row, structure) {
            const items = [];
            
            switch (structure.detectedFormat) {
                case 'Item List (Comma-separated)':
                    const itemColumn = structure.productColumns[0];
                    if (row[itemColumn]) {
                        const rawItems = row[itemColumn].split(/[,;|]/)
                            .map(item => item.trim())
                            .filter(item => item.length > 0);
                        items.push(...rawItems);
                    }
                    break;
                    
                case 'Binary Matrix (0/1 indicators)':
                    structure.productColumns.forEach(col => {
                        const value = row[col];
                        if (value && value !== 0 && value !== '0' && value !== false && value !== 'FALSE') {
                            items.push(col);
                        }
                    });
                    break;
                    
                case 'Product Columns (Text data)':
                    structure.productColumns.forEach(col => {
                        const value = row[col];
                        if (value && typeof value === 'string' && value.trim().length > 0) {
                            items.push(value.trim());
                        }
                    });
                    break;
                    
                case 'Single Item per Row':
                    const singleItemCol = structure.productColumns[0];
                    if (row[singleItemCol] && row[singleItemCol].trim()) {
                        items.push(row[singleItemCol].trim());
                    }
                    break;
                    
                case 'Quantity-based (Items with quantities)':
                    const itemCol = structure.productColumns[0];
                    if (row[itemCol]) {
                        const item = row[itemCol].trim();
                        // Find quantity columns
                        structure.productColumns.slice(1).forEach(qtyCol => {
                            const qty = parseInt(row[qtyCol]) || 1;
                            for (let i = 0; i < Math.min(qty, 5); i++) {
                                items.push(item);
                            }
                        });
                        if (items.length === 0) items.push(item); // Fallback
                    }
                    break;
                    
                default:
                    // Generic fallback - try all product columns
                    structure.productColumns.forEach(col => {
                        const value = row[col];
                        if (value && value !== '' && value !== null) {
                            if (typeof value === 'string' && value.trim()) {
                                items.push(value.trim());
                            } else if (typeof value === 'number' && value > 0) {
                                items.push(col);
                            } else if (value === true || value === 1) {
                                items.push(col);
                            }
                        }
                    });
            }
            
            // Clean and deduplicate
            return [...new Set(items.filter(item => 
                item && typeof item === 'string' && 
                item.length > 0 && item.toLowerCase() !== 'null'
            ))];
        }
        
        function parseTimestamp(dateStr) {
            if (!dateStr) return null;
            const date = new Date(dateStr);
            return isNaN(date.getTime()) ? null : date;
        }
        
        function generateRandomDate() {
            const now = new Date();
            const yearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
            return new Date(yearAgo.getTime() + Math.random() * (now.getTime() - yearAgo.getTime()));
        }
        
        function performMarketBasketAnalysis() {
            const itemCounts = {};
            const totalTransactions = processedTransactions.length;
            
            // Count item frequencies
            processedTransactions.forEach(transaction => {
                transaction.items.forEach(item => {
                    itemCounts[item] = (itemCounts[item] || 0) + 1;
                });
            });
            
            // Calculate support
            const itemSupport = {};
            Object.keys(itemCounts).forEach(item => {
                itemSupport[item] = itemCounts[item] / totalTransactions;
            });
            
            // Generate association rules
            const associationRules = generateAssociationRules(processedTransactions, itemSupport);
            
            // Calculate metrics
            const basketSizes = processedTransactions.map(t => t.items.length);
            const avgBasketSize = basketSizes.reduce((sum, size) => sum + size, 0) / basketSizes.length;
            const totalRevenue = processedTransactions.reduce((sum, t) => sum + t.amount, 0);
            
            return {
                transactions: processedTransactions,
                itemCounts: itemCounts,
                itemSupport: itemSupport,
                associationRules: associationRules,
                statistics: {
                    totalTransactions: totalTransactions,
                    uniqueProducts: Object.keys(itemCounts).length,
                    avgBasketSize: Math.round(avgBasketSize * 100) / 100,
                    strongRules: associationRules.filter(r => r.confidence >= 50 && r.lift > 1.2).length,
                    totalRevenue: totalRevenue,
                    estimatedRevenueImpact: calculateRevenueImpact(associationRules)
                }
            };
        }
        
        function generateAssociationRules(transactions, itemSupport, minSupport = 0.02, minConfidence = 0.2) {
            const rules = [];
            const items = Object.keys(itemSupport).filter(item => itemSupport[item] >= minSupport);
            
            // Generate pairwise rules
            for (let i = 0; i < items.length; i++) {
                for (let j = i + 1; j < items.length; j++) {
                    const itemA = items[i];
                    const itemB = items[j];
                    
                    let coOccurrences = 0;
                    let itemACount = 0;
                    let itemBCount = 0;
                    
                    transactions.forEach(transaction => {
                        const hasA = transaction.items.includes(itemA);
                        const hasB = transaction.items.includes(itemB);
                        
                        if (hasA) itemACount++;
                        if (hasB) itemBCount++;
                        if (hasA && hasB) coOccurrences++;
                    });
                    
                    const supportAB = coOccurrences / transactions.length;
                    const supportA = itemACount / transactions.length;
                    const supportB = itemBCount / transactions.length;
                    
                    if (supportAB >= minSupport) {
                        // Rule A -> B
                        const confidenceAB = coOccurrences / itemACount;
                        const liftAB = confidenceAB / supportB;
                        
                        if (confidenceAB >= minConfidence) {
                            rules.push({
                                antecedent: itemA,
                                consequent: itemB,
                                support: Math.round(supportAB * 1000) / 10,
                                confidence: Math.round(confidenceAB * 1000) / 10,
                                lift: Math.round(liftAB * 100) / 100,
                                strength: Math.round(confidenceAB * liftAB * 100) / 100
                            });
                        }
                        
                        // Rule B -> A
                        const confidenceBA = coOccurrences / itemBCount;
                        const liftBA = confidenceBA / supportA;
                        
                        if (confidenceBA >= minConfidence) {
                            rules.push({
                                antecedent: itemB,
                                consequent: itemA,
                                support: Math.round(supportAB * 1000) / 10,
                                confidence: Math.round(confidenceBA * 1000) / 10,
                                lift: Math.round(liftBA * 100) / 100,
                                strength: Math.round(confidenceBA * liftBA * 100) / 100
                            });
                        }
                    }
                }
            }
            
            return rules.sort((a, b) => b.strength - a.strength);
        }
        
        function calculateRevenueImpact(rules) {
            const strongRules = rules.filter(r => r.confidence >= 50 && r.lift > 1.5);
            if (strongRules.length === 0) return 8;
            
            const avgLift = strongRules.reduce((sum, rule) => sum + rule.lift, 0) / strongRules.length;
            return Math.round(((avgLift - 1) * 12) * 10) / 10;
        }
        
        function updateStatistics() {
            document.getElementById('totalTransactions').textContent = 
                analysisResults.statistics.totalTransactions.toLocaleString();
            document.getElementById('uniqueProducts').textContent = 
                analysisResults.statistics.uniqueProducts.toLocaleString();
            document.getElementById('avgBasketSize').textContent = 
                analysisResults.statistics.avgBasketSize;
            document.getElementById('strongRules').textContent = 
                analysisResults.statistics.strongRules;
            document.getElementById('revenueImpact').textContent = 
                analysisResults.statistics.estimatedRevenueImpact + '%';
        }
        
        function createVisualizationCharts() {
            createFrequencyChart();
            createRulesChart();
            createCrossSellChart();
            createRulesTable();
        }
        
        function createFrequencyChart() {
            const topItems = Object.entries(analysisResults.itemCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 15);
            
            const ctx = document.getElementById('frequencyChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: topItems.map(([item,]) => 
                        item.length > 15 ? item.substring(0, 15) + '...' : item
                    ),
                    datasets: [{
                        label: 'Frequency',
                        data: topItems.map(([, count]) => count),
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2,
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: true },
                        x: { ticks: { maxRotation: 45 } }
                    }
                }
            });
        }
        
        function createRulesChart() {
            const topRules = analysisResults.associationRules.slice(0, 20);
            const ctx = document.getElementById('rulesChart').getContext('2d');
            
            new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Association Rules',
                        data: topRules.map(rule => ({
                            x: rule.confidence,
                            y: rule.lift,
                            r: Math.max(5, rule.support)
                        })),
                        backgroundColor: 'rgba(102, 126, 234, 0.6)',
                        borderColor: 'rgba(102, 126, 234, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Confidence (%)' }
                        },
                        y: {
                            title: { display: true, text: 'Lift' },
                            beginAtZero: false
                        }
                    }
                }
            });
        }
        
        function createCrossSellChart() {
            const crossSellData = analysisResults.associationRules
                .filter(rule => rule.lift > 1.2 && rule.confidence > 30)
                .slice(0, 10);
            
            const ctx = document.getElementById('crossSellChart').getContext('2d');
            new Chart(ctx, {
                type: 'horizontalBar',
                data: {
                    labels: crossSellData.map(rule => 
                        `${rule.antecedent} → ${rule.consequent}`.length > 30 ? 
                        `${rule.antecedent} → ${rule.consequent}`.substring(0, 30) + '...' : 
                        `${rule.antecedent} → ${rule.consequent}`
                    ),
                    datasets: [{
                        label: 'Cross-Sell Strength',
                        data: crossSellData.map(rule => rule.strength),
                        backgroundColor: 'rgba(240, 147, 251, 0.8)',
                        borderColor: 'rgba(245, 87, 108, 1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: { legend: { display: false } }
                }
            });
        }
        
        function createRulesTable() {
            const topRules = analysisResults.associationRules.slice(0, 20);
            
            const tableHTML = `
                <table class="rules-table">
                    <thead>
                        <tr>
                            <th>Association Rule</th>
                            <th>Support (%)</th>
                            <th>Confidence</th>
                            <th>Lift</th>
                            <th>Strength</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topRules.map(rule => `
                            <tr>
                                <td>
                                    <strong style="color: #667eea;">${rule.antecedent}</strong>
                                    <span style="margin: 0 8px;">→</span>
                                    <strong style="color: #764ba2;">${rule.consequent}</strong>
                                </td>
                                <td>${rule.support}%</td>
                                <td>
                                    <div class="confidence-bar">
                                        <div class="confidence-fill" style="width: ${rule.confidence}%"></div>
                                    </div>
                                    ${rule.confidence}%
                                </td>
                                <td style="font-weight: 600; color: ${rule.lift > 2 ? '#10B981' : '#667eea'};">
                                    ${rule.lift}
                                </td>
                                <td style="font-weight: 700; color: #667eea;">${rule.strength}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            
            document.getElementById('rulesTable').innerHTML = tableHTML;
        }
        
        function generateBusinessInsights() {
            const insights = [];
            const topRules = analysisResults.associationRules.slice(0, 5);
            const strongRules = analysisResults.associationRules.filter(r => r.confidence >= 60 && r.lift > 1.5);
            
            insights.push(`Dataset successfully analyzed with ${datasetStructure.detectedFormat} format (${Math.round(datasetStructure.confidence * 100)}% confidence)`);
            insights.push(`Discovered ${strongRules.length} high-value cross-selling opportunities with statistical significance`);
            
            if (topRules.length > 0) {
                insights.push(`Strongest association: "${topRules[0].antecedent}" → "${topRules[0].consequent}" (${topRules[0].confidence}% confidence, ${topRules[0].lift}x lift)`);
            }
            
            const topProduct = Object.entries(analysisResults.itemCounts).sort(([,a], [,b]) => b - a)[0];
            if (topProduct) {
                const popularity = Math.round((topProduct[1] / analysisResults.statistics.totalTransactions) * 100);
                insights.push(`"${topProduct[0]}" appears in ${popularity}% of transactions - ideal anchor product for bundling strategies`);
            }
            
            insights.push(`Market basket complexity: ${analysisResults.statistics.avgBasketSize} items per transaction indicates ${analysisResults.statistics.avgBasketSize > 3 ? 'high' : 'moderate'} cross-selling potential`);
            
            document.getElementById('businessInsights').innerHTML = `
                <ul>
                    ${insights.map(insight => `<li>${insight}</li>`).join('')}
                </ul>
            `;
            
            // Generate recommendations
            const recommendations = [];
            
            strongRules.slice(0, 3).forEach((rule, index) => {
                const uplift = Math.round((rule.lift - 1) * 100);
                recommendations.push(
                    `<strong>Strategy ${index + 1}:</strong> Bundle "${rule.antecedent}" with "${rule.consequent}" for ${uplift}% higher conversion probability`
                );
            });
            
            recommendations.push(`<strong>Product Focus:</strong> Optimize inventory and promotions around top ${Math.min(10, Object.keys(analysisResults.itemCounts).length)} performing products`);
            recommendations.push(`<strong>Revenue Impact:</strong> Implementing these recommendations could increase average order value by ${analysisResults.statistics.estimatedRevenueImpact}%`);
            
            document.getElementById('actionableInsights').innerHTML = `
                <div style="display: grid; gap: 15px;">
                    ${recommendations.map(rec => `
                        <div style="padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px; border-left: 4px solid #667eea;">
                            ${rec}
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        // Export functions
        function exportToPDF() {
            const reportData = {
                title: 'Market Basket Analysis Report',
                dataset: datasetStructure.detectedFormat,
                generated: new Date().toLocaleDateString(),
                statistics: analysisResults.statistics,
                topRules: analysisResults.associationRules.slice(0, 10)
            };
            
            const reportHTML = generatePDFReport(reportData);
            downloadFile(reportHTML, `market_basket_report_${getCurrentDate()}.html`, 'text/html');
        }
        
        function exportToCSV() {
            const csvData = [
                ['Antecedent', 'Consequent', 'Support(%)', 'Confidence(%)', 'Lift', 'Strength'],
                ...analysisResults.associationRules.map(rule => [
                    rule.antecedent, rule.consequent, rule.support, 
                    rule.confidence, rule.lift, rule.strength
                ])
            ];
            
            const csvContent = csvData.map(row => row.join(',')).join('\n');
            downloadFile(csvContent, `association_rules_${getCurrentDate()}.csv`, 'text/csv');
        }
        
        function exportToJSON() {
            const exportData = {
                metadata: {
                    generated: new Date().toISOString(),
                    dataset_format: datasetStructure.detectedFormat,
                    confidence: datasetStructure.confidence,
                    total_rows_processed: datasetStructure.totalRows
                },
                statistics: analysisResults.statistics,
                association_rules: analysisResults.associationRules,
                product_analysis: analysisResults.itemCounts
            };
            
            const jsonContent = JSON.stringify(exportData, null, 2);
            downloadFile(jsonContent, `market_analysis_${getCurrentDate()}.json`, 'application/json');
        }
        
        function generatePDFReport(data) {
            return `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${data.title}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 40px; }
                        .header { text-align: center; border-bottom: 3px solid #667eea; padding-bottom: 20px; }
                        .section { margin: 30px 0; }
                        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
                        .stat-card { padding: 20px; background: #f8f9ff; border-radius: 10px; text-align: center; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { padding: 10px; border: 1px solid #ddd; }
                        th { background: #667eea; color: white; }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>${data.title}</h1>
                        <p>Dataset: ${data.dataset} | Generated: ${data.generated}</p>
                    </div>
                    <div class="section">
                        <h2>Executive Summary</h2>
                        <div class="stats">
                            <div class="stat-card">
                                <h3>${data.statistics.totalTransactions.toLocaleString()}</h3>
                                <p>Total Transactions</p>
                            </div>
                            <div class="stat-card">
                                <h3>${data.statistics.strongRules}</h3>
                                <p>Strong Rules</p>
                            </div>
                            <div class="stat-card">
                                <h3>${data.statistics.estimatedRevenueImpact}%</h3>
                                <p>Revenue Impact</p>
                            </div>
                        </div>
                    </div>
                    <div class="section">
                        <h2>Top Association Rules</h2>
                        <table>
                            <tr><th>Rule</th><th>Confidence</th><th>Lift</th><th>Support</th></tr>
                            ${data.topRules.map(rule => `
                                <tr>
                                    <td>${rule.antecedent} → ${rule.consequent}</td>
                                    <td>${rule.confidence}%</td>
                                    <td>${rule.lift}</td>
                                    <td>${rule.support}%</td>
                                </tr>
                            `).join('')}
                        </table>
                    </div>
                </body>
                </html>
            `;
        }
        
        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function getCurrentDate() {
            return new Date().toISOString().slice(0, 10);
        }
    </script>
</body>
</html>
